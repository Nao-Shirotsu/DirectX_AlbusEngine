# Direct3D11 必要処理の手順メモ

備忘録的にまとめる。 **※マークのつく項目は理解度低めだったり、自信が無い部分のため説明を保留。** 

### WinAPI でウィンドウを出す

1. **ウィンドウクラス`WNDCLASS`のインスタンスを作って各メンバを定義**

   - ウィンドウクラスのメンバ`lpfnWndProc`に、実際に実行したい処理を関数ポインタ(ラムダ式も可)で渡す。渡す関数を「ウィンドウプロシージャ」と呼ぶ。
     何もない時は`DefWindowProc()`を呼んで返り値を返すようにしておく。
   - 他のメンバは名前で空気を読んだりしていい感じにやる。大体デフォルトで問題ない。   

2. **ウィンドウクラスを登録する**

   - ウィンドウクラスのインスタンスのアドレスを`RegisterClass()`に渡して実行する。
   - `RegisterClass()`失敗に備えてエラー処理する。

3. **ウィンドウの幅を登録する**

   - `RECT`クラスのインスタンスを作り、widthなどのメンバ変数を初期化する。
   - ↑ を`AdjustWindowRect()`に引数として渡しながら実行し、大きさを登録する。

4.  **ウィンドウ作成と表示**

   - `CreateWindow()`を呼び出す。
   - ここも一応エラー処理。

   - `ShowWindow()`を呼び出す。名前が紛らわしいが一度だけ実行すればOK。
   - `UpdateWindow()`を呼び出す。同上。多分。

5. **メッセージループ**

   - `PeekMessage()`や`GetMessage()`でOSからのメッセージを受け取り、`TranslateMessage()`, `DispatchMassage()`を実行してメッセージをパースする。   
     **Get&Peek-Translate-Dispatchは3点セット**。
   - `DispatchMessage()`の引数に渡した`UINT`変数にパースされたメッセージが代入される。先ほど定義したウィンドウプロシージャ内にメッセ―ジごとの処理を書く。
     例えば、`msg == WM_KEYDOWN`ならキーボード入力の処理を書くなど。

6. **ウィンドウを閉じる**

   - `WM_CLOSE`というメッセージを任意のタイミングで`PostMessage()`で送信する。
     また、ウィンドウのxを押すと`DefWindowProc()`が勝手に送信してくれる。
   - `DefWindowProc()`が`WM_CLOSE`を受信すると勝手に`WM_DESTROY`を送信する。
     `WM_DESTROY`を自分で定義したウィンドウプロシージャで受信し、`PostQuitMessage()`を呼び出す。するとその後`DefWindowProc()`から勝手にWM_QUITが送信される。
   - `UnregisterClass()`を呼び出し、2で登録したウィンドウをUnregisterする。

7. **その他**

   - このメッセージループ処理とそのほかを並列処理すれば効率が良いかもしれない。

   - 文字コードを統一する。`MBCS("hoge")`, `Unicode(L"fuga")`, `UTF-16(U"bar")※`など。   

     ​						↑ 関数じゃないよ

### D3D11 の初期化

0. **ウィンドウプロシージャの変更 ※**

      - `WM_PAINT`メッセージを受信するように変更し、`PAINTSTRUCT`, `HDC`を使って処理をする。

1. **デバイスとスワップチェインの設定/作成**

   アプリケーションを起動するときに一度だけ行う処理。※

   - `D3D_FEATURE_LEVEL`列挙型で機能レベルを決める。D3Dのバージョン(9とか10.1とか11とか)のうちど(どこまで)利用するのか選択する作業。 
   - `D3D11_CREATE_DEVICE_DEBUG`なんかすると使用するAPIレイヤーに「デバッグ機能」を含める。
   - `DXGI_SWAP_CHAIN_DESC`の実体を作り、メンバ変数を定義することでスワップチェインの設定をする。WinAPIのウィンドウクラス登録と同じような要領でやる。
     - `ZeroMemory()`で`DXGI_SWAP_CHAIN_DESC` のインスタンスを初期化する。インスタンスのメンバで値を定義しないものがあるならこれを呼んでおけばいい。デフォルトな感じにやってくれる。
     - バックバッファ、←の縦横幅、リフレッシュレート、マルチサンプルなどを設定する。
   - `D3D11CreateDeviceAndSwapChain()`で名前通りのことをする。引数がめっちゃ多いので暗記はそもそも無理。本に書いてあるので見ながら書こう。
     - `DXGI_SWAP_CHAIN_DESC` などのインスタンスを引数に渡す。
     - 第2引数でドライバを指定できる。「ハードウェア」「ソフトウェア(WARP)」「リファレンス」のいずれかを使う必要があり、いずれかを指定しなければいけなｄい。※

2. **バックバッファへの描画**

   - 描画するターゲットとなるバックバッファを取得する。`ID3D11Texture2D`のポインタに`IDXGISwapChain::GetBuffer()`を実行して取得する。バックバッファはスワップチェインの0番目なので、それを第1引数で指定する。
   - 描画ターゲットビューを作る。`ID3D11Device::CreateRenderTargetView()`に前項のポインタと、インスタンスを持たせたい描画ターゲットビューを引数として渡して実行する。
   - 描画ターゲットビューを出力マージャ―(D3D11レンダリングパイプラインの最後のステージ)にセットする。`ID3D11DeviceContext::OMSetRenderTargets()`の引数に前項で使った描画ターゲットビューを渡す。
   - ビューポート(描画するスクリーンのこと)を設定する。`D3D11_VIEWPORT`構造体のメンバを初期化して`ID3D11DviceContext::RSSetViewports()`に渡し、いろいろやるらしい。
   - HLSLのコンパイルを`D3DX11CompileFromFile()で`実行し、`ID3DBlob`型のポインタでバイトデータとして持つ。その後`ID3D11Device::CreateVertexShader()`でシェーダオブジェクトを作成する。実際に使われるのはこいつらしい。シェーダオブジェクトを作ったらもうバイトデータは不要になるので解放していい。   
     ピクセルシェーダに関しても同じことをやる。
   - パイプラインへの頂点情報の読み込み方を`D3D11_INPUT_ELEMENT_DESC`構造体で指定する。   
     `ID3D11Device::CreateInputLayout()`の引数に渡しながら実行する。
   - デプス/ステンシルテクスチャを作成する。     
     `D3D11_TEXTURE2D_DESC`のインスタンスを作って`ID3D11Texture2D*`に`CreateTexture2D()`する。
     ちなみにsample2だとデプステバッファを生成していない。
   - デプス/ステンシルビューを作成する。     
     `ID3D11DepthStencilView`に`CreateDepthStencilView()`する。
   - デプス/ステンシルビューを出力マージャ―に設定する。`OMSetRenderTargets()`に渡す。   
     描画ターゲットビューと同時に引数に渡すと良いようだ。

3. **毎フレームの更新処理**

    - `ClearRenderTargetView()`でセットされている描画ターゲットビューに対して全消去する。
    - 深度バッファを使っている場合はクリアする必要がある。`ClearDepthStencilView()`でやる。
    - `Present()`メソッドでバックバッファの内容を実際に画面に描画する。   

4. **終了処理**

    はじめに`DeviceContext`のポインタに対して`pointer->ClearState()`をやった後、   
    `ID3DXXX*`というポインタに動的確保した奴らをすべて解放するだけ。   
    だいたいは`if( pointer ){ pointer->Release(); }`で終了。   

5. **その他雑記**

    - 隠面処理
    オブジェクトを描画するときにより手前にあるモノを優先して描画するための処理。
      Zソート法(遅い)とZバッファ法(速い)というのがあるらしい。
    - デバイス消失のエラー処理
    デバイスは全ての処理を操っているようなので、これが消失していたら基本的にやばいのでアプリ終了などの処理をしてやらないといけない。

