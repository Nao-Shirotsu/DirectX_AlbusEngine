# Direct3D11 必要処理の手順メモ

備忘録。※マークのつく項目は理解度低めだったり、自信が無い部分のため説明を保留。

### WinAPI でウィンドウを出す

1. **ウィンドウクラス`WNDCLASS`のインスタンスを作って各メンバを定義**

   - ウィンドウクラスのメンバ`lpfnWndProc`に、実際に実行したい処理を関数ポインタ(ラムダ式も可)で渡す。渡す関数を「ウィンドウプロシージャ」と呼ぶ。
     何もない時は`DefWindowProc()`を呼んで返り値を返すようにしておく。
   - 他のメンバは名前で空気を読んだりしていい感じにやる。大体デフォルトで問題ない。   

2. **ウィンドウクラスを登録する**

   - ウィンドウクラスのインスタンスのアドレスを`RegisterClass()`に渡して実行する。
   - `RegisterClass()`失敗に備えてエラー処理する。

3. **ウィンドウの幅を登録する**

   - `RECT`クラスのインスタンスを作り、widthなどのメンバ変数を初期化する。
   - ↑ を`AdjustWindowRect()`に引数として渡しながら実行し、大きさを登録する。

4.  **ウィンドウ作成と表示**

   - `CreateWindow()`を呼び出す。
   - ここも一応エラー処理。

   - `ShowWindow()`を呼び出す。名前が紛らわしいが一度だけ実行すればOK。
   - `UpdateWindow()`を呼び出す。同上。多分。

5. **メッセージループ**

   - `PeekMessage()`や`GetMessage()`でOSからのメッセージを受け取り、`TranslateMessage()`, `DispatchMassage()`を実行してメッセージをパースする。   
     **Get&Peek-Translate-Dispatchは3点セット**。
   - `DispatchMessage()`の引数に渡した`UINT`変数にパースされたメッセージが代入される。先ほど定義したウィンドウプロシージャ内にメッセ―ジごとの処理を書く。
     例えば、`msg == WM_KEYDOWN`ならキーボード入力の処理を書くなど。

6. **ウィンドウを閉じる**

   - `WM_CLOSE`というメッセージを任意のタイミングで`PostMessage()`で送信する。
     また、ウィンドウのxを押すと`DefWindowProc()`が勝手に送信してくれる。
   - `DefWindowProc()`が`WM_CLOSE`を受信すると勝手に`WM_DESTROY`を送信する。
     `WM_DESTROY`を自分で定義したウィンドウプロシージャで受信し、`PostQuitMessage()`を呼び出す。するとその後`DefWindowProc()`から勝手にWM_QUITが送信される。
   - `UnregisterClass()`を呼び出し、2で登録したウィンドウをUnregisterする。

7. **その他**

   - このメッセージループ処理とそのほかを並列処理すれば効率が良いかもしれない。
   - 文字コードを統一する。`MBCS("hoge")`, `Unicode(L"fuga")`, `UTF-16(U"bar")※`など。

### D3D11 の初期化

0. **ウィンドウプロシージャの変更 ※**
   - `WM_PAINT`メッセージを受信するように変更し、`PAINTSTRUCT`, `HDC`を使って処理をする。
1. **デバイスとスワップチェインの設定/作成**
   - `D3D_FEATURE_LEVEL`列挙型で機能レベルを決める。D3Dのバージョン選択みたいなもの。   
   - `DXGI_SWAP_CHAIN_DESC` ウィンドウクラスの要領でスワップチェインの設定をする。
     - `ZeroMemory()`で`DXGI_SWAP_CHAIN_DESC` のインスタンスを初期化する。インスタンスのメンバで値を定義しないものがあるならこれを呼んでおけばいい。デフォルトな感じにやってくれる。
     - バックバッファ、←の縦横幅、リフレッシュレート、マルチサンプルなどを設定する。
2. **深度/ステンシルバッファの作成**
3. **アプリケーション本体の処理**
4. **毎フレームの更新処理**
5. **終了処理**